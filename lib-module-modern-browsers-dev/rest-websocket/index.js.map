{"version":3,"sources":["../../src/rest-websocket/index.js"],"names":["Logger","encode","decode","logger","init","io","restService","on","openWatchers","Set","socket","forEach","watcher","stop","args","callback","type","restName","json","Error","Array","isArray","debug","restResource","get","info","options","createCursor","user","then","cursor","toArray","results","catch","error","err","message","result","key","eventName","otherArgs","startsWith","query","queries","emit","add","warn"],"mappings":"AAAA,OAAOA,MAAP;AACA,SAASC,MAAT,EAAiBC,MAAjB,QAA+B,kBAA/B;;;AAEA,MAAMC,SAAS,IAAIH,MAAJ,CAAW,qBAAX,CAAf;;AAEA,eAAe,SAASI,IAAT,CAAcC,EAAd,EAAkBC,WAAlB,EAA+B;AAC5CD,KAAGE,EAAH,CAAM,YAAN,EAAoB,kBAAU;AAC5B,QAAIC,eAAe,IAAIC,GAAJ,EAAnB;;AAEAC,WAAOH,EAAP,CAAU,YAAV,EAAwB,YAAM;AAC5BC,mBAAaG,OAAb,CAAqB;AAAA,eAAWC,QAAQC,IAAR,EAAX;AAAA,OAArB,CAD4B;AAE7B,KAFD,CAH4B,EAO5BH,OAAOH,EAAP,CACE,MADF,EAEE,gBAEEO,IAFF,EAGEC,QAHF,EAIK;AAAA,sBAFC,QAAE,WAAC,QAAM,OAAN,CAAD,CAAF,EAAgB,YAAhB,CAED;;AAAA,0BADK,WAAG,YAAH,CACL;;AAAA;AAAA,UAHH,EAAEC,IAAF,EAAQC,QAAR,EAAkBC,IAAlB,EAGG,GAHqB,SAAI,mBAAM,UAAN,CAAJ,EAAkB,uBAAU,UAAV,CAAlB,EAAoC,mBAAM,WAAC,UAAD,CAAN,CAApC,CAGrB;;AACH,UAAI;AACF,YAAIA,IAAJ,EAAU;AACR,cAAmBH,QAAnB,EACE,MAAM,IAAII,KAAJ,CAAU,4BAAV,CAAN;;AAKF,cAFAJ,gCAAWD,IAAX,CAEA,EADAA,wBAAOZ,OAAOgB,IAAP,CAAP,CACA,EAAI,CAACE,MAAMC,OAAN,CAAcP,IAAd,CAAL,KACEX,OAAOmB,KAAP,CAAa,MAAb,EAAqB,EAAER,IAAF,EAArB,CADF,EAGMC,QAHN,GAII,MAAM,IAAII,KAAJ,CAAU,cAAV,CAAN;AAGL;;AAED,YAAI,CAACJ,QAAL,EAEE,YADAZ,OAAqB,MAArB,EAAuC,kBAAvC,CACA;;AAGF,cAAMoB,eAAejB,YAAYkB,GAAZ,CAAgBP,QAAhB,CAArB;;AAGA,gBADAd,OAAOsB,IAAP,CAAY,MAAZ,EAAoB,EAAET,IAAF,EAAQC,QAAR,EAAkBH,IAAlB,EAApB,CACA,EAAQE,IAAR;AACE,eAAK,gBAAL;AAAuB;AACrB,oBAAM,CAACU,OAAD,IAAYZ,IAAlB;AACA,qBAAOR,YACJqB,YADI,CACSJ,YADT,EACuBb,OAAOkB,IAD9B,EACoCF,OADpC,EAEJG,IAFI,CAEC;AAAA,uBAAUC,OAAOC,OAAP,EAAV;AAAA,eAFD,EAGJF,IAHI,CAGC;AAAA,uBAAWd,SAAS,IAAT,EAAed,OAAO+B,OAAP,CAAf,CAAX;AAAA,eAHD,EAIJC,KAJI,CAIE,eAAO;AACZ9B,uBAAO+B,KAAP,CAAalB,IAAb,EAAmBmB,GAAnB,CADY,EAEZpB,SAASoB,IAAIC,OAAb,CAFY;AAGb,eAPI,CAAP;AAQD;;AAED,eAAK,WAAL;AACA,eAAK,WAAL;AACA,eAAK,eAAL;AACA,eAAK,oBAAL;AACA,eAAK,kBAAL;AACA,eAAK,mBAAL;AACA,eAAK,aAAL;AACA,eAAK,WAAL;AACA,eAAK,SAAL;AACE,gBAAI;AACF,kBAAmB,CAACb,aAAaP,IAAb,CAApB,EACE,MAAM,IAAIG,KAAJ,CAAW,SAAQF,QAAS,IAAGD,IAAK,mBAApC,CAAN;;AAGF;AACA,qBAAOO,aAAaP,IAAb,EAAmBN,OAAOkB,IAA1B,EAAgC,GAAGd,IAAnC,EACJe,IADI,CACC;AAAA,uBAAUd,SAAS,IAAT,EAAed,OAAOoC,MAAP,CAAf,CAAV;AAAA,eADD,EAEJJ,KAFI,CAEE,eAAO;AACZ9B,uBAAO+B,KAAP,CAAalB,IAAb,EAAmB,EAAEmB,GAAF,EAAnB,CADY,EAEZpB,SAASoB,IAAIC,OAAJ,IAAeD,GAAxB,CAFY;AAGb,eALI,CAAP;AAMD,aAZD,CAYE,OAAOA,GAAP,EAAY;AACZhC,qBAAO+B,KAAP,CAAalB,IAAb,EAAmB,EAAEmB,GAAF,EAAnB,CADY,EAEZpB,SAASoB,IAAIC,OAAJ,IAAeD,GAAxB,CAFY;AAGb;AACD;;AAEF,eAAK,OAAL;AACA,eAAK,WAAL;AACA,eAAK,mBAAL;AACE,gBAAI;AACF,oBAAM,CAACG,GAAD,EAAMC,SAAN,EAAiBC,cAAjB,IAAmC1B,IAAzC;;AAEA,kBAAI,CAACwB,IAAIG,UAAJ,CAAe,OAAf,CAAL,EACE,MAAM,IAAItB,KAAJ,CAAU,mBAAV,CAAN;;AAGF,oBAAMuB,QAAQnB,aAAaoB,OAAb,CAAqBL,GAArB,CAAd,CAPE,CAOuC;AACzC,kBAAI,CAACI,KAAL,EACE,MAAM,IAAIvB,KAAJ,CAAW,SAAQF,QAAS,IAAGD,IAAK,IAAGsB,GAAI,mBAA3C,CAAN;;AAGF,kBAAItB,SAAS,OAAb;AACE;AACA,uBAAO0B,MAAM1B,IAAN,EAAY;AAAA,yBAAUD,SAAS,IAAT,EAAesB,UAAUpC,OAAOoC,MAAP,CAAzB,CAAV;AAAA,iBAAZ,EAAgE,GAAGG,SAAnE,EACJP,KADI,CACE,eAAO;AACZ9B,yBAAO+B,KAAP,CAAalB,IAAb,EAAmB,EAAEmB,GAAF,EAAnB,CADY,EAEZpB,SAASoB,IAAIC,OAAJ,IAAeD,GAAxB,CAFY;AAGb,iBAJI,CAAP,CAFF,KAOO;AACL,sBAAMvB,UAAU8B,MAAM1B,IAAN,EAAY,UAACmB,GAAD,EAAME,MAAN,EAAiB;AACvCF,qBADuC,IAEzChC,OAAO+B,KAAP,CAAalB,IAAb,EAAmB,EAAEmB,GAAF,EAAnB,CAFyC,EAK3CzB,OAAOkC,IAAP,CAAYL,SAAZ,EAAuBJ,GAAvB,EAA4BE,UAAUpC,OAAOoC,MAAP,CAAtC,CAL2C;AAM5C,iBANe,CAAhB;AAOAzB,wBAAQiB,IAAR,CACE;AAAA,yBAAMd,UAAN;AAAA,iBADF,EAEE,eAAO;AACLZ,yBAAO+B,KAAP,CAAalB,IAAb,EAAmB,EAAEmB,GAAF,EAAnB,CADK,EAELpB,SAASoB,IAAIC,OAAJ,IAAeD,GAAxB,CAFK;AAGN,iBALH,CARK,EAgBL3B,aAAaqC,GAAb,CAAiBjC,OAAjB,CAhBK;AAiBN;AACF,aArCD,CAqCE,OAAOuB,GAAP,EAAY;AACZhC,qBAAO+B,KAAP,CAAalB,IAAb,EAAmB,EAAEmB,GAAF,EAAnB,CADY,EAEZpB,SAASoB,IAAIC,OAAJ,IAAeD,GAAxB,CAFY;AAGb;AACD;;AAEF;AACE,gBAAI;AACFhC,qBAAO2C,IAAP,CAAY,iBAAZ,EAA+B,EAAE9B,IAAF,EAA/B,CADE,EAEFD,SAAU,0BAAyBC,IAAK,GAAxC,CAFE;AAGH,aAHD,CAGE,OAAOmB,GAAP,EAAY;AACZhC,qBAAO+B,KAAP,CAAalB,IAAb,EAAmB,EAAEmB,GAAF,EAAnB,CADY,EAEZpB,SAASoB,IAAIC,OAAJ,IAAeD,GAAxB,CAFY;AAGb;AA7FL;AA+FD,OAxHD,CAwHE,OAAOA,GAAP,EAAY;AACZhC,eAAO2C,IAAP,CAAY,YAAZ,EAA0B,EAAEX,GAAF,EAA1B,CADY,EAEZpB,SAASoB,IAAIC,OAAJ,IAAeD,GAAxB,CAFY;AAGb;AACF,KAnIH,CAP4B;AA4I7B,GA5ID,CAD4C;AA8I7C","file":"index.js","sourcesContent":["import Logger from 'nightingale-logger/src';\nimport { encode, decode } from '../extended-json';\n\nconst logger = new Logger('liwi:rest-websocket');\n\nexport default function init(io, restService) {\n  io.on('connection', socket => {\n    let openWatchers = new Set();\n\n    socket.on('disconnect', () => {\n      openWatchers.forEach(watcher => watcher.stop());\n    });\n\n    socket.on(\n      'rest',\n      (\n        { type, restName, json }: { type: string, restName: string, json: ?string },\n        args: ?Array<any> | Function,\n        callback: ?Function,\n      ) => {\n        try {\n          if (json) {\n            if (!PRODUCTION && callback) {\n              throw new Error('Cannot have args and json.');\n            }\n\n            callback = args;\n            args = decode(json);\n            if (!Array.isArray(args)) {\n              logger.debug('args', { args });\n\n              if (callback) {\n                throw new Error('Invalid args');\n              }\n            }\n          }\n\n          if (!callback) {\n            logger[!PRODUCTION ? 'warn' : 'error']('callback missing');\n            return;\n          }\n\n          const restResource = restService.get(restName);\n\n          logger.info('rest', { type, restName, args });\n          switch (type) {\n            case 'cursor toArray': {\n              const [options] = args;\n              return restService\n                .createCursor(restResource, socket.user, options)\n                .then(cursor => cursor.toArray())\n                .then(results => callback(null, encode(results)))\n                .catch(err => {\n                  logger.error(type, err);\n                  callback(err.message);\n                });\n            }\n\n            case 'insertOne':\n            case 'updateOne':\n            case 'updateSeveral':\n            case 'partialUpdateByKey':\n            case 'partialUpdateOne':\n            case 'partialUpdateMany':\n            case 'deleteByKey':\n            case 'deleteOne':\n            case 'findOne':\n              try {\n                if (!PRODUCTION && !restResource[type]) {\n                  throw new Error(`rest: ${restName}.${type} is not available`);\n                }\n\n                // eslint-disable-next-line prettier/prettier\n                return restResource[type](socket.user, ...args)\n                  .then(result => callback(null, encode(result)))\n                  .catch(err => {\n                    logger.error(type, { err });\n                    callback(err.message || err);\n                  });\n              } catch (err) {\n                logger.error(type, { err });\n                callback(err.message || err);\n              }\n              break;\n\n            case 'fetch':\n            case 'subscribe':\n            case 'fetchAndSubscribe':\n              try {\n                const [key, eventName, otherArgs = []] = args;\n\n                if (!key.startsWith('query')) {\n                  throw new Error('Invalid query key');\n                }\n\n                const query = restResource.queries[key]; // todo pass connected user\n                if (!query) {\n                  throw new Error(`rest: ${restName}.${type}.${key} is not available`);\n                }\n\n                if (type === 'fetch') {\n                  // eslint-disable-next-line prettier/prettier\n                  return query[type](result => callback(null, result && encode(result)), ...otherArgs)\n                    .catch(err => {\n                      logger.error(type, { err });\n                      callback(err.message || err);\n                    });\n                } else {\n                  const watcher = query[type]((err, result) => {\n                    if (err) {\n                      logger.error(type, { err });\n                    }\n\n                    socket.emit(eventName, err, result && encode(result));\n                  });\n                  watcher.then(\n                    () => callback(),\n                    err => {\n                      logger.error(type, { err });\n                      callback(err.message || err);\n                    },\n                  );\n\n                  openWatchers.add(watcher);\n                }\n              } catch (err) {\n                logger.error(type, { err });\n                callback(err.message || err);\n              }\n              break;\n\n            default:\n              try {\n                logger.warn('Unknown command', { type });\n                callback(`rest: unknown command \"${type}\"`);\n              } catch (err) {\n                logger.error(type, { err });\n                callback(err.message || err);\n              }\n          }\n        } catch (err) {\n          logger.warn('rest error', { err });\n          callback(err.message || err);\n        }\n      },\n    );\n  });\n}\n"]}