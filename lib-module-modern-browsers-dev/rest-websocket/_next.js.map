{"version":3,"sources":["../../src/rest-websocket/_next.js"],"names":["Logger","MAX_OPENED_CURSORS","logger","init","io","restService","on","socket","openCursors","Map","timeouts","activeListeners","closeCursor","id","clearTimeout","delete","close","forEach","cursor","timeout","listener","nextIdCursor","args","callback","type","restName","info","size","options","createCursor","set","setTimeout","warn","then","toArray","results","catch","err","message","typeCursorAction","idCursor","cursorArgs","get","result"],"mappings":"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","file":"_next.js","sourcesContent":["import Logger from 'nightingale-logger';\n\nconst MAX_OPENED_CURSORS = 5;\nconst logger = new Logger('liwi:rest-websocket');\n\nexport default function init(io, restService) {\n  io.on('connection', (socket) => {\n    let openCursors = new Map();\n    let timeouts = new Map();\n    let activeListeners = new Map();\n\n    const closeCursor = (id) => {\n      clearTimeout(timeouts[id]);\n      timeouts.delete(id);\n      openCursors[id].close();\n      openCursors.delete(id);\n    };\n\n    socket.on('disconnect', () => {\n      openCursors.forEach(cursor => cursor.close());\n      timeouts.forEach(timeout => clearTimeout(timeout));\n      activeListeners.forEach(listener => listener.close());\n\n      openCursors = null;\n      timeouts = null;\n      activeListeners = null;\n    });\n\n    let nextIdCursor = 1;\n\n    socket.on('rest', (\n      { type, restName }: { type: string, restName: string },\n      args: Array<any>,\n      callback: Function,\n    ) => {\n      logger.info('rest', { type, restName, args });\n      switch (type) {\n        case 'createCursor': {\n          if (openCursors.size > MAX_OPENED_CURSORS) return callback('too many cursors');\n\n          const id = nextIdCursor++;\n          const [options] = args;\n          const cursor = restService.createCursor(restName, options);\n          if (!cursor) return callback('failed to create cursor');\n\n          timeouts.set(id, setTimeout(() => {\n            logger.warn('socket closed by timeout', { id, restName });\n            closeCursor(id);\n          }));\n\n          return callback(null, id);\n        }\n\n        case 'cursor toArray': {\n          const [options] = args;\n          return restService.createCursor(restName, options)\n                        .then(cursor => cursor.toArray())\n                        .then(results => callback(null, results))\n                        .catch(err => callback(err.message));\n        }\n\n        case 'cursor': {\n          const [{ type: typeCursorAction, id: idCursor }, cursorArgs] = args;\n\n          const cursor = openCursors.get(idCursor);\n          if (!cursor) return callback(`failed to find cursor \"${idCursor}\"`);\n          switch (typeCursorAction) {\n            case 'close':\n              closeCursor(idCursor);\n              return callback();\n\n            case 'advance':\n            case 'next':\n            case 'count':\n              return cursor[type](...cursorArgs)\n                                .then(result => callback(null, result))\n                                .catch(err => callback(err.message || err));\n                            /* cursor.next().then((key) => {\n                                if (!key) return callback(null);\n                                return cursor.result();\n                            }).then(result => {\n                                    response(null, restService.transform(data));\n                                });\n                            }, () => {\n                                response(null);\n                            }); */\n\n            default:\n              callback(`Unknown command: \"${type}\"`);\n          }\n\n          break;\n        }\n\n        case 'insertOne':\n        case 'updateOne':\n        case 'updateSeveral':\n        case 'partialUpdateByKey':\n        case 'partialUpdateOne':\n        case 'partialUpdateMany':\n        case 'deleteByKey':\n        case 'deleteOne':\n        case 'findOne':\n          return restService[type](restName, ...args)\n                        .then(result => callback(null, result))\n                        .catch(err => callback(err.message || err));\n\n        default:\n          callback(`Unknown command: \"${type}\"`);\n      }\n    });\n  });\n}\n"]}