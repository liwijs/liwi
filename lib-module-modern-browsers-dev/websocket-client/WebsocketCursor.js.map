{"version":3,"sources":["../../src/websocket-client/WebsocketCursor.js"],"names":["WebsocketStore","AbstractCursor","ResultType","WebsocketCursor","constructor","store","options","_options","limit","newLimit","_idCursor","Error","Promise","resolve","_create","connection","emit","then","idCursor","type","args","id","advance","count","next","_result","result","key","_store","keyPath","applyLimit","close","closedPromise","toArray"],"mappings":"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","file":"WebsocketCursor.js","sourcesContent":["import WebsocketStore from './WebsocketStore';\nimport AbstractCursor from '../store/AbstractCursor';\nimport type { ResultType } from '../types';\n\nexport default class WebsocketCursor extends AbstractCursor<WebsocketStore> {\n  _idCursor: ?number;\n  _options: ?Object;\n  _result: ?Object;\n\n  constructor(store: WebsocketStore, options) {\n    super(store);\n    this._options = options;\n  }\n\n  /* options */\n\n  limit(newLimit: number): Promise<this> {\n    if (this._idCursor) throw new Error('Cursor already created');\n    this._options.limit = newLimit;\n    return Promise.resolve(this);\n  }\n\n  /* results */\n\n  _create() {\n    if (this._idCursor) throw new Error('Cursor already created');\n    return this.store.connection.emit('createCursor', this._options).then(idCursor => {\n      if (!idCursor) return;\n      this._idCursor = idCursor;\n    });\n  }\n\n  emit(type, ...args): Promise<any> {\n    if (!this._idCursor) {\n      return this._create().then(() => this.emit(type, ...args));\n    }\n\n    return this.store.emit('cursor', { type, id: this._idCursor }, args);\n  }\n\n  advance(count: number) {\n    this.emit('advance', count);\n    return this;\n  }\n\n  next(): Promise<?any> {\n    return this.emit('next').then(result => {\n      this._result = result;\n      this.key = result && result[this._store.keyPath];\n      return this.key;\n    });\n  }\n\n  result(): Promise<?ResultType> {\n    return Promise.resolve(this._result);\n  }\n\n  count(applyLimit: boolean = false) {\n    return this.emit('count', applyLimit);\n  }\n\n  close(): Promise<void> {\n    if (!this._store) return Promise.resolve();\n\n    const closedPromise = this._idCursor ? this.emit('close') : Promise.resolve();\n    this._idCursor = null;\n    this._options = null;\n    this._store = undefined;\n    this._result = undefined;\n    return closedPromise;\n  }\n\n  toArray(): Promise<Array<Array<ResultType>>> {\n    return this.store.emit('cursor toArray', this._options).then(result => {\n      this.close();\n      return result;\n    });\n  }\n}\n"]}