{"version":3,"sources":["../../src/rest-websocket/index.js"],"names":["Logger","encode","decode","logger","init","io","restService","on","socket","openWatchers","Set","forEach","watcher","stop","args","callback","type","restName","buffer","Error","restResource","get","info","options","createCursor","user","then","cursor","toArray","results","catch","err","error","message","result","key","eventName","otherArgs","startsWith","query","queries","emit","add","warn"],"mappings":"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","file":"index.js","sourcesContent":["/* global PRODUCTION */\nimport Logger from 'nightingale-logger/src';\nimport { encode, decode } from '../msgpack';\n\nconst logger = new Logger('liwi:rest-websocket');\n\nexport default function init(io, restService) {\n  io.on('connection', (socket) => {\n    let openWatchers = new Set();\n\n    socket.on('disconnect', () => {\n      openWatchers.forEach(watcher => watcher.stop());\n    });\n\n    socket.on('rest', (\n      { type, restName, buffer }: { type: string, restName: string, buffer: ?string },\n      args: ?Array<any>|Function,\n      callback: ?Function,\n    ) => {\n      try {\n        if (buffer) {\n          if (!PRODUCTION && callback) {\n            throw new Error('Cannot have args and buffer.');\n          }\n\n          callback = args;\n          args = decode(buffer);\n        }\n\n        if (!PRODUCTION && !callback) {\n          throw new Error('`callback` missing.');\n        }\n\n        const restResource = restService.get(restName);\n\n        logger.info('rest', { type, restName, args });\n        switch (type) {\n          case 'cursor toArray': {\n            const [options] = args;\n            return restService.createCursor(restResource, socket.user, options)\n              .then(cursor => cursor.toArray())\n              .then(results => callback(null, encode(results)))\n              .catch((err) => {\n                logger.error(type, err);\n                callback(err.message);\n              });\n          }\n\n\n          case 'insertOne':\n          case 'updateOne':\n          case 'updateSeveral':\n          case 'partialUpdateByKey':\n          case 'partialUpdateOne':\n          case 'partialUpdateMany':\n          case 'deleteByKey':\n          case 'deleteOne':\n          case 'findOne':\n            try {\n              if (!PRODUCTION && !restResource[type]) {\n                throw new Error(`rest: ${restName}.${type} is not available`);\n              }\n\n              return restResource[type](socket.user, ...args)\n                .then(result => callback(null, encode(result)))\n                .catch((err) => {\n                  logger.error(type, { err });\n                  callback(err.message || err);\n                });\n            } catch (err) {\n              logger.error(type, { err });\n              callback(err.message || err);\n            }\n            break;\n\n          case 'fetch':\n          case 'subscribe':\n          case 'fetchAndSubscribe':\n            try {\n              const [key, eventName, otherArgs = []] = args;\n\n              if (!key.startsWith('query')) {\n                throw new Error('Invalid query key');\n              }\n\n              const query = restResource.queries[key]; // todo pass connected user\n              if (!query) {\n                throw new Error(`rest: ${restName}.${type}.${key} is not available`);\n              }\n\n              if (type === 'fetch') {\n                return query[type](result => callback(null, result && encode(result)), ...otherArgs)\n                  .catch((err) => {\n                    logger.error(type, { err });\n                    callback(err.message || err);\n                  });\n              } else {\n                const watcher = query[type]((err, result) => {\n                  if (err) {\n                    logger.error(type, { err });\n                  }\n                  socket.emit(eventName, err, encode(result));\n                });\n                watcher.then(() => callback(), err => {\n                  logger.error(type, { err });\n                  callback(err.message || err);\n                });\n\n                openWatchers.add(watcher);\n              }\n            } catch (err) {\n              logger.error(type, { err });\n              callback(err.message || err);\n            }\n            break;\n\n          default:\n            try {\n              logger.warn('Unknown command', { type });\n              callback(`rest: unknown command \"${type}\"`);\n            } catch (err) {\n              logger.error(type, { err });\n              callback(err.message || err);\n            }\n        }\n      } catch (err) {\n        logger.warn('rest error', { err });\n        callback(err.message || err);\n      }\n    });\n  });\n}\n"]}