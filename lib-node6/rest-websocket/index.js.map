{"version":3,"sources":["../../src/rest-websocket/index.js"],"names":[],"mappings":";;;;;;ypBAAA;;kBAMwB,I;;AAJxB;;;;;;AAEA,MAAM,SAAS,gCAAW,qBAAX,CAAf;;AAEe,SAAS,IAAT,CAAc,EAAd,EAAkB,WAAlB,EAA+B;AAC5C,KAAG,EAAH,CAAM,YAAN,EAAoB,UAAU;AAC5B,WAAO,EAAP,CAAU,MAAV,EAAkB,OAEhB,IAFgB,EAGhB,QAHgB,KAIb;AAAA,UAHD,IAGC,QAHD,IAGC;AAAA,UAHK,QAGL,QAHK,QAGL;;AACH,aAAO,IAAP,CAAY,MAAZ,EAAoB,EAAE,IAAF,EAAQ,QAAR,EAAkB,IAAlB,EAApB;AACA,cAAQ,IAAR;AACE,aAAK,gBAAL;AAAuB;AAAA,uCACH,IADG;;AAAA,kBACd,OADc;;AAErB,mBAAO,YAAY,YAAZ,CAAyB,QAAzB,EAAmC,OAAO,IAA1C,EAAgD,OAAhD,EACQ,IADR,CACa,UAAU,OAAO,OAAP,EADvB,EAEQ,IAFR,CAEa,WAAW,SAAS,IAAT,EAAe,OAAf,CAFxB,EAGQ,KAHR,CAGc,OAAO;AACZ,qBAAO,KAAP,CAAa,IAAb,EAAmB,GAAnB;AACA,uBAAS,IAAI,OAAb;AACD,aANR,CAAP;AAOD;;AAED,aAAK,WAAL;AACA,aAAK,WAAL;AACA,aAAK,eAAL;AACA,aAAK,oBAAL;AACA,aAAK,kBAAL;AACA,aAAK,mBAAL;AACA,aAAK,aAAL;AACA,aAAK,WAAL;AACA,aAAK,SAAL;AACE,cAAI;AACF,kBAAM,eAAe,YAAY,GAAZ,CAAgB,QAAhB,CAArB;;;AAKA,mBAAO,aAAa,IAAb,EAAmB,OAAO,IAA1B,EAAgC,GAAG,IAAnC,EACU,IADV,CACe,UAAU,SAAS,IAAT,EAAe,MAAf,CADzB,EAEU,KAFV,CAEgB,OAAO;AACZ,qBAAO,KAAP,CAAa,IAAb,EAAmB,EAAE,GAAF,EAAnB;AACA,uBAAS,IAAI,OAAJ,IAAe,GAAxB;AACD,aALV,CAAP;AAMD,WAZD,CAYE,OAAO,GAAP,EAAY;AACZ,mBAAO,KAAP,CAAa,IAAb,EAAmB,EAAE,GAAF,EAAnB;AACA,qBAAS,IAAI,OAAJ,IAAe,GAAxB;AACD;AACD;;AAEF;AACE,iBAAO,IAAP,CAAY,iBAAZ,EAA+B,EAAE,IAAF,EAA/B;AACA,mBAAU,sBAAoB,IAAK,IAAnC;AAzCJ;AA2CD,KAjDD;AAkDD,GAnDD;AAoDD","file":"index.js","sourcesContent":["/* global PRODUCTION */\n\nimport Logger from 'nightingale-logger';\n\nconst logger = new Logger('liwi.rest-websocket');\n\nexport default function init(io, restService) {\n  io.on('connection', socket => {\n    socket.on('rest', (\n      { type, restName }: { type: string, restName: string },\n      args: Array,\n      callback: Function,\n    ) => {\n      logger.info('rest', { type, restName, args });\n      switch (type) {\n        case 'cursor toArray': {\n          const [options] = args;\n          return restService.createCursor(restName, socket.user, options)\n                        .then(cursor => cursor.toArray())\n                        .then(results => callback(null, results))\n                        .catch(err => {\n                          logger.error(type, err);\n                          callback(err.message);\n                        });\n        }\n\n        case 'insertOne':\n        case 'updateOne':\n        case 'updateSeveral':\n        case 'partialUpdateByKey':\n        case 'partialUpdateOne':\n        case 'partialUpdateMany':\n        case 'deleteByKey':\n        case 'deleteOne':\n        case 'findOne':\n          try {\n            const restResource = restService.get(restName);\n            if (!PRODUCTION && !restResource[type]) {\n              throw new Error(`${restName}.${type} is not available`);\n            }\n\n            return restResource[type](socket.user, ...args)\n                            .then(result => callback(null, result))\n                            .catch(err => {\n                              logger.error(type, { err });\n                              callback(err.message || err);\n                            });\n          } catch (err) {\n            logger.error(type, { err });\n            callback(err.message || err);\n          }\n          break;\n\n        default:\n          logger.warn('Unknown command', { type });\n          callback(`Unknown command: \"${type}\"`);\n      }\n    });\n  });\n}\n"]}