{"version":3,"sources":["../../src/react-redux/applyChange.js"],"names":["state","change","type","old_offset","oldOffset","new_offset","newOffset","old_val","oldVal","new_val","newVal","copy","slice","splice","index","findIndex","x","id","Error","JSON","stringify","push"],"mappings":"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","file":"applyChange.js","sourcesContent":["import deepEqual from 'deep-equal';\n\ntype ObjectArrayType = Array<Object>;\n\ntype ChangeType = {\n  type: string,\n  state: ?string,\n  old_offset: ?number,\n  new_offset: ?number,\n  old_val: ?Object,\n  new_val: ?Object,\n};\n\n// https://github.com/rethinkdb/horizon/blob/next/client/src/ast.js\nexport default (state: ObjectArrayType, change: ChangeType) => {\n  const {\n    type,\n    old_offset: oldOffset,\n    new_offset: newOffset,\n    old_val: oldVal,\n    new_val: newVal,\n  } = change;\n\n  const copy = () => (state = state.slice());\n\n  switch (type) {\n    case 'remove':\n    case 'uninitial': {\n      copy();\n      // Remove old values from the array\n      if (oldOffset != null) {\n        state.splice(oldOffset, 1);\n      } else {\n        const index = state.findIndex(x => deepEqual(x.id, oldVal.id));\n        if (index === -1) {\n          // Programming error. This should not happen\n          throw new Error(`change couldn't be applied: ${JSON.stringify(change)}`);\n        }\n        state.splice(index, 1);\n      }\n      break;\n    }\n\n    case 'initial': {\n      copy();\n\n      if (newOffset != null) {\n        state[newOffset] = newVal;\n      } else {\n        // If we don't have an offset, find the old val and\n        // replace it with the new val\n        const index = state.findIndex(x => deepEqual(x.id, newVal.id));\n        if (index === -1) {\n          state.push(newVal);\n        } else {\n          state[index] = newVal;\n        }\n      }\n      break;\n    }\n\n    case 'add': {\n      copy();\n      // Add new values to the array\n      if (newOffset != null) {\n        // If we have an offset, put it in the correct location\n        state.splice(newOffset, 0, newVal);\n      } else {\n        // otherwise for unordered results, push it on the end\n        state.push(newVal);\n      }\n      break;\n    }\n\n    case 'change': {\n      copy();\n\n      if (oldOffset === newOffset) {\n        state[newOffset] = newVal;\n        return state;\n      }\n\n      // Modify in place if a change is happening\n      if (oldOffset != null) {\n        // Remove the old document from the results\n        state.splice(oldOffset, 1);\n      }\n\n      if (newOffset != null) {\n        // Splice in the new val if we have an offset\n        state.splice(newOffset, 0, newVal);\n      } else {\n        // If we don't have an offset, find the old val and\n        // replace it with the new val\n        const index = state.findIndex(x => deepEqual(x.id, oldVal.id));\n        if (index === -1) {\n          // indicates a programming bug. The server gives us the\n          // ordering, so if we don't find the id it means something is\n          // buggy.\n          throw new Error(`change couldn't be applied: ${JSON.stringify(change)}`);\n        } else {\n          state[index] = newVal;\n        }\n      }\n      break;\n    }\n    case 'state': {\n      // This gets hit if we have not emitted yet, and should\n      // result in an empty array being output.\n      break;\n    }\n    default:\n      throw new Error(`unrecognized 'type' field from server ${JSON.stringify(change)}`);\n  }\n  return state;\n};\n"]}