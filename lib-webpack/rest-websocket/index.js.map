{"version":3,"sources":["../../src/rest-websocket/index.js"],"names":["Logger","encode","decode","logger","init","io","restService","on","socket","args","callback","type","restName","buffer","console","log","info","options","createCursor","user","then","cursor","toArray","results","catch","err","error","message","restResource","get","result","key","query","Error","warn"],"mappings":";;;;AAAA;AACA,OAAOA,MAAP,MAAmB,oBAAnB;AACA,SAASC,MAAT,EAAiBC,MAAjB,QAA+B,YAA/B;;AAEA,IAAMC,SAAS,IAAIH,MAAJ,CAAW,qBAAX,CAAf;;AAOA,eAAe,SAASI,IAAT,CAAcC,EAAd,EAAkBC,WAAlB,EAA+B;AAC5CD,KAAGE,EAAH,CAAM,YAAN,EAAoB,UAACC,MAAD,EAAY;AAC9BA,WAAOD,EAAP,CAAU,MAAV,EAAkB,gBAEhBE,IAFgB,EAGhBC,QAHgB,EAIb;AAAA,UAHDC,IAGC,QAHDA,IAGC;AAAA,UAHKC,QAGL,QAHKA,QAGL;AAAA,UAHeC,MAGf,QAHeA,MAGf;;AACH,UAAIA,MAAJ,EAAY;;AAKVH,mBAAWD,IAAX;AACAA,eAAOP,OAAOW,MAAP,CAAP;AACAC,gBAAQC,GAAR,CAAYN,IAAZ;AACD;;AAMDN,aAAOa,IAAP,CAAY,MAAZ,EAAoB,EAAEL,UAAF,EAAQC,kBAAR,EAAkBH,UAAlB,EAApB;AACA,cAAQE,IAAR;AACE,aAAK,gBAAL;AAAuB;AAAA,wBACHF,IADG;;AAAA;;AAAA,gBACdQ,OADc;;AAErB,mBAAOX,YAAYY,YAAZ,CAAyBN,QAAzB,EAAmCJ,OAAOW,IAA1C,EAAgDF,OAAhD,EACJG,IADI,CACC;AAAA,qBAAUC,OAAOC,OAAP,EAAV;AAAA,aADD,EAEJF,IAFI,CAEC;AAAA,qBAAWV,SAAS,IAAT,EAAeT,OAAOsB,OAAP,CAAf,CAAX;AAAA,aAFD,EAGJC,KAHI,CAGE,UAACC,GAAD,EAAS;AACdtB,qBAAOuB,KAAP,CAAaf,IAAb,EAAmBc,GAAnB;AACAf,uBAASe,IAAIE,OAAb;AACD,aANI,CAAP;AAOD;;AAGD,aAAK,WAAL;AACA,aAAK,WAAL;AACA,aAAK,eAAL;AACA,aAAK,oBAAL;AACA,aAAK,kBAAL;AACA,aAAK,mBAAL;AACA,aAAK,aAAL;AACA,aAAK,WAAL;AACA,aAAK,SAAL;AACE,cAAI;AACF,gBAAMC,eAAetB,YAAYuB,GAAZ,CAAgBjB,QAAhB,CAArB;;;AAKA,mBAAOgB,aAAajB,IAAb,uBAAmBH,OAAOW,IAA1B,4BAAmCV,IAAnC,IACJW,IADI,CACC;AAAA,qBAAUV,SAAS,IAAT,EAAeT,OAAO6B,MAAP,CAAf,CAAV;AAAA,aADD,EAEJN,KAFI,CAEE,UAACC,GAAD,EAAS;AACdtB,qBAAOuB,KAAP,CAAaf,IAAb,EAAmB,EAAEc,QAAF,EAAnB;AACAf,uBAASe,IAAIE,OAAJ,IAAeF,GAAxB;AACD,aALI,CAAP;AAMD,WAZD,CAYE,OAAOA,GAAP,EAAY;AACZtB,mBAAOuB,KAAP,CAAaf,IAAb,EAAmB,EAAEc,QAAF,EAAnB;AACAf,qBAASe,IAAIE,OAAJ,IAAeF,GAAxB;AACD;AACD;;AAEF,aAAK,aAAL;AACA,aAAK,iBAAL;AACE,cAAId,SAAS,aAAb,EAA4B;AAC1BA,mBAAO,OAAP;AACD;AACD,cAAIA,SAAS,iBAAb,EAAgC;AAC9BA,mBAAO,WAAP;AACD;;AAED,cAAI;AACF,gBAAMiB,gBAAetB,YAAYuB,GAAZ,CAAgBjB,QAAhB,CAArB;AACA,gBAAMmB,MAAMtB,KAAK,CAAL,CAAZ;;AAEA,gBAAMuB,QAAQJ,cAAaI,KAAb,uBAAmBxB,OAAOW,IAA1B,4BAAmCV,IAAnC,GAAd;AACA,gBAAI,CAACuB,KAAL,EAAY;AACV,oBAAM,IAAIC,KAAJ,YAAmBrB,QAAnB,SAA+BD,IAA/B,SAAuCoB,GAAvC,uBAAN;AACD;;AAED,gBAAIpB,SAAS,OAAb,EAAsB;AACpB,qBAAOqB,MAAMrB,IAAN,EAAY;AAAA,uBAAUD,SAAS,IAAT,EAAeT,OAAO6B,MAAP,CAAf,CAAV;AAAA,eAAZ,EACJN,KADI,CACE,UAACC,GAAD,EAAS;AACdtB,uBAAOuB,KAAP,CAAaf,IAAb,EAAmB,EAAEc,QAAF,EAAnB;AACAf,yBAASe,IAAIE,OAAJ,IAAeF,GAAxB;AACD,eAJI,CAAP;AAKD,aAND,MAMO;AACLf,uBAAS,IAAT,EAAe,QAAf;AACAA,uBAAS,IAAT,EAAe,QAAf;AACAA,uBAAS,IAAT,EAAe,QAAf;AACAA,uBAAS,IAAT,EAAe,QAAf;AACAA,uBAAS,IAAT,EAAe,QAAf;AACAA,uBAAS,IAAT,EAAe,QAAf;AACAA,uBAAS,IAAT,EAAe,QAAf;AACAA,uBAAS,IAAT,EAAe,QAAf;AACAA,uBAAS,IAAT,EAAe,QAAf;AACAA,uBAAS,IAAT,EAAe,QAAf;AACAA,uBAAS,IAAT,EAAe,QAAf;AACD;AACF,WA5BD,CA4BE,OAAOe,GAAP,EAAY;AACZtB,mBAAOuB,KAAP,CAAaf,IAAb,EAAmB,EAAEc,QAAF,EAAnB;AACAf,qBAASe,IAAIE,OAAJ,IAAeF,GAAxB;AACD;AACD;;AAEF;AACE,cAAI;AACFtB,mBAAO+B,IAAP,CAAY,iBAAZ,EAA+B,EAAEvB,UAAF,EAA/B;AACAD,iDAAmCC,IAAnC;AACD,WAHD,CAGE,OAAOc,GAAP,EAAY;AACZtB,mBAAOuB,KAAP,CAAaf,IAAb,EAAmB,EAAEc,QAAF,EAAnB;AACAf,qBAASe,IAAIE,OAAJ,IAAeF,GAAxB;AACD;AA1FL;AA4FD,KAhHD;AAiHD,GAlHD;AAmHD","file":"index.js","sourcesContent":["/* global PRODUCTION */\nimport Logger from 'nightingale-logger';\nimport { encode, decode } from '../msgpack';\n\nconst logger = new Logger('liwi.rest-websocket');\n\ntype ObjectBufferType = {\n  type: 'Buffer',\n  data: Array<number>,\n}\n\nexport default function init(io, restService) {\n  io.on('connection', (socket) => {\n    socket.on('rest', (\n      { type, restName, buffer }: { type: string, restName: string, buffer: ?ObjectBufferType },\n      args: ?Array<any>|Function,\n      callback: ?Function,\n    ) => {\n      if (buffer) {\n        if (!PRODUCTION && callback) {\n          throw new Error('Cannot have args and buffer.');\n        }\n\n        callback = args;\n        args = decode(buffer);\n        console.log(args);\n      }\n\n      if (!PRODUCTION && !callback) {\n        throw new Error('`callback` missing.');\n      }\n\n      logger.info('rest', { type, restName, args });\n      switch (type) {\n        case 'cursor toArray': {\n          const [options] = args;\n          return restService.createCursor(restName, socket.user, options)\n            .then(cursor => cursor.toArray())\n            .then(results => callback(null, encode(results)))\n            .catch((err) => {\n              logger.error(type, err);\n              callback(err.message);\n            });\n        }\n\n\n        case 'insertOne':\n        case 'updateOne':\n        case 'updateSeveral':\n        case 'partialUpdateByKey':\n        case 'partialUpdateOne':\n        case 'partialUpdateMany':\n        case 'deleteByKey':\n        case 'deleteOne':\n        case 'findOne':\n          try {\n            const restResource = restService.get(restName);\n            if (!PRODUCTION && !restResource[type]) {\n              throw new Error(`rest: ${restName}.${type} is not available`);\n            }\n\n            return restResource[type](socket.user, ...args)\n              .then(result => callback(null, encode(result)))\n              .catch((err) => {\n                logger.error(type, { err });\n                callback(err.message || err);\n              });\n          } catch (err) {\n            logger.error(type, { err });\n            callback(err.message || err);\n          }\n          break;\n\n        case 'query:fetch':\n        case 'query:subscribe':\n          if (type === 'query:fetch') {\n            type = 'fetch';\n          }\n          if (type === 'query:subscribe') {\n            type = 'subscribe';\n          }\n\n          try {\n            const restResource = restService.get(restName);\n            const key = args[0];\n\n            const query = restResource.query(socket.user, ...args);\n            if (!query) {\n              throw new Error(`rest: ${restName}.${type}.${key} is not available`);\n            }\n\n            if (type === 'fetch') {\n              return query[type](result => callback(null, encode(result)))\n                .catch((err) => {\n                  logger.error(type, { err });\n                  callback(err.message || err);\n                });\n            } else {\n              callback(null, 'coucou');\n              callback(null, 'coucou');\n              callback(null, 'coucou');\n              callback(null, 'coucou');\n              callback(null, 'coucou');\n              callback(null, 'coucou');\n              callback(null, 'coucou');\n              callback(null, 'coucou');\n              callback(null, 'coucou');\n              callback(null, 'coucou');\n              callback(null, 'coucou');\n            }\n          } catch (err) {\n            logger.error(type, { err });\n            callback(err.message || err);\n          }\n          break;\n\n        default:\n          try {\n            logger.warn('Unknown command', { type });\n            callback(`rest: unknown command \"${type}\"`);\n          } catch (err) {\n            logger.error(type, { err });\n            callback(err.message || err);\n          }\n      }\n    });\n  });\n}\n"]}