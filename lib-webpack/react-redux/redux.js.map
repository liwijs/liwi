{"version":3,"sources":["../../src/react-redux/redux.js"],"names":["deepEqual","createAction","alpReactReduxCreateAction","createSubscribeAction","actionName","change","subscribeReducer","state","type","oldOffset","old_offset","newOffset","new_offset","oldVal","old_val","newVal","new_val","copy","slice","splice","index","findIndex","x","id","Error","JSON","stringify","push"],"mappings":"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","file":"redux.js","sourcesContent":["import deepEqual from 'deep-equal';\n// eslint-disable-next-line\nimport { createAction as alpReactReduxCreateAction } from 'alp-react-redux';\n\nexport function createSubscribeAction(actionName: string) {\n  return alpReactReduxCreateAction(actionName, (change: Object) => ({ change }));\n}\n\ntype ChangeType = {\n  type: ?string,\n  state: ?string,\n  old_offset: ?number,\n  new_offset: ?number,\n  old_val: ?Object,\n  new_val: ?Object,\n}\n\n// https://github.com/rethinkdb/horizon/blob/next/client/src/ast.js\nexport function subscribeReducer(state: Array<Object>, { change }: { change: ChangeType }) {\n  const {\n    type,\n    old_offset: oldOffset,\n    new_offset: newOffset,\n    old_val: oldVal,\n    new_val: newVal,\n  } = change;\n\n  const copy = () => state = state.slice();\n\n  switch (type) {\n    case 'remove':\n    case 'uninitial': {\n      copy();\n      // Remove old values from the array\n      if (oldOffset != null) {\n        state.splice(oldOffset, 1);\n      } else {\n        const index = state.findIndex(x => deepEqual(x.id, oldVal.id));\n        if (index === -1) {\n          // Programming error. This should not happen\n          throw new Error(`change couldn't be applied: ${JSON.stringify(change)}`);\n        }\n        state.splice(index, 1);\n      }\n      break;\n    }\n\n    case 'initial': {\n      copy();\n\n      if (newOffset != null) {\n        state[newOffset] = newVal;\n      } else {\n        // If we don't have an offset, find the old val and\n        // replace it with the new val\n        const index = state.findIndex(x => deepEqual(x.id, newVal.id));\n        if (index === -1) {\n          state.push(newVal);\n        } else {\n          state[index] = newVal;\n        }\n      }\n      break;\n    }\n\n    case 'add': {\n      copy();\n      // Add new values to the array\n      if (newOffset != null) {\n        // If we have an offset, put it in the correct location\n        state.splice(newOffset, 0, newVal);\n      } else {\n        // otherwise for unordered results, push it on the end\n        state.push(newVal);\n      }\n      break;\n    }\n\n    case 'change': {\n      copy();\n\n      if (oldOffset === newOffset) {\n        state[newOffset] = newVal;\n        return state;\n      }\n\n      // Modify in place if a change is happening\n      if (oldOffset != null) {\n        // Remove the old document from the results\n        state.splice(oldOffset, 1);\n      }\n\n      if (newOffset != null) {\n        // Splice in the new val if we have an offset\n        state.splice(newOffset, 0, newVal);\n      } else {\n        // If we don't have an offset, find the old val and\n        // replace it with the new val\n        const index = state.findIndex(x => deepEqual(x.id, oldVal.id));\n        if (index === -1) {\n          // indicates a programming bug. The server gives us the\n          // ordering, so if we don't find the id it means something is\n          // buggy.\n          throw new Error(`change couldn't be applied: ${JSON.stringify(change)}`);\n        } else {\n          state[index] = newVal;\n        }\n      }\n      break;\n    }\n    case 'state': {\n      // This gets hit if we have not emitted yet, and should\n      // result in an empty array being output.\n      break;\n    }\n    default:\n      throw new Error(\n        `unrecognized 'type' field from server ${JSON.stringify(change)}`);\n  }\n  return state;\n}\n"]}