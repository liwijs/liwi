{"version":3,"file":"index-browsermodern.es.js","sources":["../src/AbstractSubscribableStoreQuery.ts","../src/SubscribeStore.ts"],"sourcesContent":["import {\n  Query,\n  SubscribeCallback,\n  QuerySubscription,\n  QueryResult,\n} from 'liwi-store';\nimport { BaseModel, InsertType, AllowedKeyValue } from 'liwi-types';\nimport SubscribeStore from './SubscribeStore';\n\nexport default abstract class AbstractSubscribableStoreQuery<\n  KeyPath extends string,\n  KeyValue extends AllowedKeyValue,\n  Model extends BaseModel & Record<KeyPath, KeyValue>,\n  ModelInsertType extends InsertType<Model, KeyPath>,\n  Result = Model\n> implements Query<Result, never, KeyValue> {\n  changeParams(params: never): never {\n    throw new Error('Method not supported. Please create a new query.');\n  }\n\n  changePartialParams(params: never): never {\n    throw new Error('Method not supported. Please create a new query.');\n  }\n\n  private _subscribeStore?: SubscribeStore<\n    KeyPath,\n    KeyValue,\n    Model,\n    ModelInsertType,\n    any,\n    any\n  >;\n\n  setSubscribeStore(\n    store: SubscribeStore<KeyPath, KeyValue, Model, ModelInsertType, any, any>,\n  ): void {\n    this._subscribeStore = store;\n  }\n\n  getSubscribeStore(): SubscribeStore<\n    KeyPath,\n    KeyValue,\n    Model,\n    ModelInsertType,\n    any,\n    any\n  > {\n    if (!this._subscribeStore) {\n      throw new Error('_subscribeStore is not initialized');\n    }\n    return this._subscribeStore;\n  }\n\n  abstract fetch<T>(\n    onFulfilled: (result: QueryResult<Result>) => T,\n  ): Promise<T>;\n\n  fetchAndSubscribe(\n    callback: SubscribeCallback<KeyValue, Result>,\n  ): QuerySubscription {\n    return this._subscribe(callback, true);\n  }\n\n  subscribe(callback: SubscribeCallback<KeyValue, Result>): QuerySubscription {\n    return this._subscribe(callback, false);\n  }\n\n  abstract _subscribe(\n    callback: SubscribeCallback<KeyValue, Result>,\n    _includeInitial: boolean,\n  ): QuerySubscription;\n}\n","/* eslint-disable max-lines */\nimport {\n  Store as StoreInterface,\n  AbstractConnection,\n  UpsertResult,\n  SubscribableStoreQuery,\n  AbstractStoreCursor,\n  SubscribableStore,\n} from 'liwi-store';\nimport {\n  BaseModel,\n  InsertType,\n  Update,\n  Criteria,\n  Sort,\n  QueryOptions,\n  Transformer,\n  AllowedKeyValue,\n} from 'liwi-types';\n\nexport type Actions<Model> =\n  | { type: 'inserted'; next: Model[] }\n  | { type: 'updated'; changes: [Model, Model][] }\n  | { type: 'deleted'; prev: Model[] };\n\nexport type Listener<Model> = (action: Actions<Model>) => unknown;\n\nexport default class SubscribeStore<\n  KeyPath extends string,\n  KeyValue extends AllowedKeyValue,\n  Model extends BaseModel & Record<KeyPath, KeyValue>,\n  ModelInsertType extends InsertType<Model, KeyPath>,\n  Connection extends AbstractConnection,\n  Store extends SubscribableStore<\n    KeyPath,\n    KeyValue,\n    Model,\n    ModelInsertType,\n    Connection\n  >\n>\n  implements\n    StoreInterface<KeyPath, KeyValue, Model, ModelInsertType, Connection> {\n  private readonly store: Store;\n\n  private readonly listeners: Set<Listener<Model>> = new Set();\n\n  readonly keyPath: KeyPath;\n\n  constructor(store: Store) {\n    this.store = store;\n    this.keyPath = store.keyPath;\n  }\n\n  get connection(): Connection {\n    return this.store.connection;\n  }\n\n  subscribe(callback: Listener<Model>): () => void {\n    this.listeners.add(callback);\n    return () => this.listeners.delete(callback);\n  }\n\n  callSubscribed(action: Actions<Model>): void {\n    this.listeners.forEach((listener) => listener(action));\n  }\n\n  createQuerySingleItem<Result extends Record<KeyPath, KeyValue>>(\n    options: QueryOptions<Model>,\n    transformer?: Transformer<Model, Result>,\n  ): SubscribableStoreQuery<\n    SubscribableStore<KeyPath, KeyValue, Model, ModelInsertType, Connection>,\n    Result,\n    KeyValue\n  > {\n    const query: SubscribableStoreQuery<\n      SubscribableStore<KeyPath, KeyValue, Model, ModelInsertType, Connection>,\n      Result,\n      KeyValue\n    > = this.store.createQuerySingleItem<Result>(options, transformer);\n    query.setSubscribeStore(this);\n    return query;\n  }\n\n  createQueryCollection<Item extends Record<KeyPath, KeyValue>>(\n    options: QueryOptions<Model>,\n    transformer?: Transformer<Model, Item>,\n  ): SubscribableStoreQuery<\n    SubscribableStore<KeyPath, KeyValue, Model, ModelInsertType, Connection>,\n    Item[],\n    KeyValue\n  > {\n    const query: SubscribableStoreQuery<\n      SubscribableStore<KeyPath, KeyValue, Model, ModelInsertType, Connection>,\n      Item[],\n      KeyValue\n    > = this.store.createQueryCollection<Item>(options, transformer);\n    query.setSubscribeStore(this);\n    return query;\n  }\n\n  findAll(criteria?: Criteria<Model>, sort?: Sort<Model>): Promise<Model[]> {\n    return this.store.findAll(criteria, sort);\n  }\n\n  findByKey(key: any, criteria?: Criteria<Model>): Promise<Model | undefined> {\n    return this.store.findByKey(key, criteria);\n  }\n\n  findOne(\n    criteria: Criteria<Model>,\n    sort?: Sort<Model>,\n  ): Promise<Model | undefined> {\n    return this.store.findOne(criteria, sort);\n  }\n\n  async insertOne(object: ModelInsertType): Promise<Model> {\n    const inserted = await this.store.insertOne(object);\n    this.callSubscribed({ type: 'inserted', next: [inserted] });\n    return inserted;\n  }\n\n  async replaceOne(object: Model): Promise<Model> {\n    const replaced = await this.store.replaceOne(object);\n    this.callSubscribed({ type: 'updated', changes: [[object, replaced]] });\n    return replaced;\n  }\n\n  async replaceSeveral(objects: Model[]): Promise<Model[]> {\n    const replacedObjects = await this.store.replaceSeveral(objects);\n    this.callSubscribed({\n      type: 'updated',\n      changes: objects.map((prev, index) => [prev, replacedObjects[index]]),\n    });\n    return replacedObjects;\n  }\n\n  async upsertOne(object: ModelInsertType): Promise<Model> {\n    const result = await this.upsertOneWithInfo(object);\n    return result.object;\n  }\n\n  async upsertOneWithInfo(\n    object: ModelInsertType,\n  ): Promise<UpsertResult<Model>> {\n    const upsertedWithInfo = await this.store.upsertOneWithInfo(object);\n    if (upsertedWithInfo.inserted) {\n      this.callSubscribed({\n        type: 'inserted',\n        next: [upsertedWithInfo.object],\n      });\n    } else {\n      throw new Error('TODO');\n    }\n    return upsertedWithInfo;\n  }\n\n  async partialUpdateByKey(\n    key: any,\n    partialUpdate: Update<Model>,\n    criteria?: Criteria<Model>,\n  ): Promise<Model> {\n    return this.partialUpdateOne(\n      (await this.findOne({ [this.store.keyPath]: key, ...criteria })) as Model,\n      partialUpdate,\n    );\n  }\n\n  async partialUpdateOne(\n    object: Model,\n    partialUpdate: Update<Model>,\n  ): Promise<Model> {\n    const updated = await this.store.partialUpdateOne(object, partialUpdate);\n    this.callSubscribed({ type: 'updated', changes: [[object, updated]] });\n    return updated;\n  }\n\n  async partialUpdateMany(\n    criteria: Criteria<Model>,\n    partialUpdate: Update<Model>,\n  ): Promise<void> {\n    const cursor = await this.store.cursor(criteria);\n    const changes: [Model, Model][] = [];\n\n    await cursor.forEach(async (model) => {\n      const key = model[this.store.keyPath];\n      const updated = await this.store.partialUpdateByKey(\n        key,\n        partialUpdate,\n        criteria,\n      );\n      changes.push([model, updated]);\n    });\n    this.callSubscribed({ type: 'updated', changes });\n  }\n\n  async deleteByKey(key: any, criteria?: Criteria<Model>): Promise<void> {\n    return this.deleteOne((await this.findByKey(key, criteria)) as Model);\n  }\n\n  async deleteOne(object: Model): Promise<void> {\n    await this.store.deleteOne(object);\n    this.callSubscribed({ type: 'deleted', prev: [object] });\n  }\n\n  async deleteMany(criteria: Criteria<Model>): Promise<void> {\n    const cursor = await this.store.cursor(criteria);\n    const prev: Model[] = await cursor.toArray();\n    await this.store.deleteMany(criteria);\n    this.callSubscribed({ type: 'deleted', prev });\n  }\n\n  async cursor<Result = Model>(\n    criteria?: Criteria<Model>,\n    sort?: Sort<Model>,\n  ): Promise<AbstractStoreCursor<any, KeyValue, Model, Result>> {\n    const cursor = await this.store.cursor<Result>(criteria, sort);\n    cursor.overrideStore(this);\n    return cursor;\n  }\n}\n"],"names":["AbstractSubscribableStoreQuery","changeParams","Error","changePartialParams","setSubscribeStore","store","_subscribeStore","getSubscribeStore","fetchAndSubscribe","callback","_subscribe","subscribe","SubscribeStore","constructor","listeners","Set","keyPath","connection","add","delete","callSubscribed","action","forEach","listener","createQuerySingleItem","options","transformer","query","createQueryCollection","findAll","criteria","sort","findByKey","key","findOne","insertOne","object","inserted","type","next","replaceOne","replaced","changes","replaceSeveral","objects","replacedObjects","map","prev","index","upsertOne","result","upsertOneWithInfo","upsertedWithInfo","partialUpdateByKey","partialUpdate","partialUpdateOne","updated","partialUpdateMany","cursor","model","push","deleteByKey","deleteOne","deleteMany","toArray","overrideStore"],"mappings":"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"}