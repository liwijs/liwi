{"version":3,"file":"index-browser-dev.cjs.js","sources":["../src/AbstractConnection.ts","../src/AbstractCursor.ts","../src/AbstractStoreCursor.ts","../src/AbstractQuery.ts","../src/AbstractStore.ts"],"sourcesContent":["export default abstract class AbstractConnection {\n  abstract getConnection(): Promise<any>;\n\n  abstract close(): Promise<void>;\n}\n","/* eslint-disable no-await-in-loop */\n\nimport { BaseModel } from 'liwi-types';\n\nexport default abstract class AbstractCursor<\n  Model extends BaseModel,\n  KeyPath extends string,\n  Result extends Partial<Model> = Model\n> {\n  abstract close(): Promise<void> | void;\n\n  abstract next(): Promise<any>;\n\n  nextResult(): Promise<Result> {\n    return this.next().then(() => this.result());\n  }\n\n  abstract limit(newLimit: number): Promise<this>;\n\n  abstract count(applyLimit: boolean /*  = false */): Promise<number>;\n\n  abstract toArray(): Promise<Result[]>;\n\n  abstract result(): Promise<Result>;\n\n  async forEachKeys(\n    callback: (key: any) => Promise<void> | void,\n  ): Promise<void> {\n    while (true) {\n      const key = await this.next();\n      if (!key) return;\n\n      await callback(key);\n    }\n  }\n\n  forEach(callback: (result: Result) => Promise<void> | void): Promise<void> {\n    return this.forEachKeys(() =>\n      this.result().then((result) => callback(result)),\n    );\n  }\n\n  *keysIterator() {\n    while (true) {\n      yield this.next();\n    }\n  }\n\n  *[Symbol.iterator]() {\n    // eslint-disable-next-line no-restricted-syntax\n    for (const keyPromise of this.keysIterator()) {\n      yield keyPromise.then((key) => key && this.result());\n    }\n  }\n\n  // TODO Symbol.asyncIterator, https://phabricator.babeljs.io/T7356\n  /*\n    async *keysAsyncIterator() {\n        while (true) {\n             const key = await this.next();\n             if (!key) return;\n\n             yield key;\n        }\n     }\n\n     async *[Symbol.asyncIterator] {\n        for await (let key of this.keysAsyncIterator()) {\n            yield await this.result();\n        }\n     }\n     */\n}\n","/* eslint-disable no-await-in-loop */\n\nimport { BaseModel } from 'liwi-types';\nimport AbstractCursor from './AbstractCursor';\nimport InternalCommonStoreClient from './InternalCommonStoreClient';\n\nexport default abstract class AbstractStoreCursor<\n  Model extends BaseModel,\n  KeyPath extends string,\n  Store extends InternalCommonStoreClient<Model, KeyPath, any>,\n  Result extends Partial<Model> = Model\n> extends AbstractCursor<Model, KeyPath, Result> {\n  key: any;\n\n  protected _store: Store;\n\n  constructor(store: Store) {\n    super();\n    this._store = store;\n  }\n\n  get store(): Store {\n    return this._store;\n  }\n\n  overrideStore(store: Store) {\n    this._store = store;\n  }\n\n  result(): Promise<Result> {\n    if (!this.key) throw new Error('Cannot call result() before next()');\n    return (this.store.findByKey(this.key) as unknown) as Promise<Result>;\n  }\n\n  delete(): Promise<void> {\n    return this.store.deleteByKey(this.key);\n  }\n}\n","import { BaseModel, Changes, Fields, Criteria, Sort } from 'liwi-types';\n\nexport interface QueryOptions<Model extends BaseModel> {\n  fields?: Fields<Model>;\n  criteria?: Criteria<Model>;\n  sort?: Sort<Model>;\n}\n\nexport interface SubscribeResult<Value> {\n  cancel: () => void;\n  stop: () => void;\n  then: (\n    onFulfilled: (value: Value) => any,\n    onRejected?: (error: any) => any,\n  ) => Promise<any>;\n}\n\nexport type SubscribeCallback<Value> = (\n  err: Error | null,\n  changes: Changes<Value>,\n) => void;\n\nexport default abstract class AbstractQuery<Value> {\n  abstract fetch(onFulfilled?: (value: Value[]) => any): Promise<any>;\n\n  fetchAndSubscribe(callback: SubscribeCallback<Value>) {\n    return this._subscribe(callback, true);\n  }\n\n  subscribe(callback: SubscribeCallback<Value>) {\n    return this._subscribe(callback, false);\n  }\n\n  abstract _subscribe(\n    callback: SubscribeCallback<Value>,\n    _includeInitial: boolean,\n  ): SubscribeResult<Value[]>;\n}\n","import assert from 'assert';\nimport {\n  BaseModel,\n  InsertType,\n  Update,\n  Criteria,\n  Sort,\n  QueryOptions,\n  Transformer,\n} from 'liwi-types';\nimport Store, { UpsertResult } from './Store';\nimport AbstractConnection from './AbstractConnection';\nimport AbstractStoreCursor from './AbstractStoreCursor';\nimport AbstractQuery from './AbstractQuery';\n\nexport default abstract class AbstractStore<\n  Model extends BaseModel,\n  KeyPath extends string,\n  Connection extends AbstractConnection,\n  Cursor extends AbstractStoreCursor<Model, KeyPath, any>\n> implements Store<Model, KeyPath, Connection, Cursor> {\n  private readonly _connection: Connection;\n\n  readonly keyPath: KeyPath;\n\n  constructor(connection: Connection, keyPath: KeyPath) {\n    assert(connection);\n    this._connection = connection;\n    this.keyPath = keyPath;\n  }\n\n  get connection(): Connection {\n    return this._connection;\n  }\n\n  abstract createQuery<Transformed>(\n    options: QueryOptions<Model>,\n    transformer?: Transformer<Model, Transformed>,\n  ): AbstractQuery<Transformed>;\n\n  findAll(criteria?: Criteria<Model>, sort?: Sort<Model>): Promise<Model[]> {\n    return this.cursor(criteria, sort).then((cursor: Cursor) =>\n      cursor.toArray(),\n    );\n  }\n\n  abstract findByKey(\n    key: any,\n    criteria?: Criteria<Model>,\n  ): Promise<Model | undefined>;\n\n  abstract findOne(\n    criteria: Criteria<Model>,\n    sort?: Sort<Model>,\n  ): Promise<Model | undefined>;\n\n  abstract cursor(\n    criteria?: Criteria<Model>,\n    sort?: Sort<Model>,\n  ): Promise<Cursor>;\n\n  abstract insertOne(object: InsertType<Model, KeyPath>): Promise<Model>;\n\n  abstract replaceOne(object: Model): Promise<Model>;\n\n  abstract replaceSeveral(objects: Model[]): Promise<Model[]>;\n\n  async upsertOne(object: InsertType<Model, KeyPath>): Promise<Model> {\n    const result = await this.upsertOneWithInfo(object);\n    return result.object;\n  }\n\n  abstract upsertOneWithInfo(\n    object: InsertType<Model, KeyPath>,\n  ): Promise<UpsertResult<Model>>;\n\n  abstract partialUpdateByKey(\n    key: any,\n    partialUpdate: Update<Model>,\n    criteria?: Criteria<Model>,\n  ): Promise<Model>;\n\n  abstract partialUpdateOne(\n    object: Model,\n    partialUpdate: Update<Model>,\n  ): Promise<Model>;\n\n  abstract partialUpdateMany(\n    criteria: Criteria<Model>,\n    partialUpdate: Update<Model>,\n  ): Promise<void>;\n\n  abstract deleteByKey(key: any, criteria?: Criteria<Model>): Promise<void>;\n\n  deleteOne(object: Model): Promise<void> {\n    return this.deleteByKey(object[this.keyPath]);\n  }\n\n  abstract deleteMany(selector: Criteria<Model>): Promise<void>;\n}\n"],"names":["AbstractConnection","AbstractCursor","nextResult","next","then","result","forEachKeys","callback","key","forEach","keysIterator","Symbol","iterator","keyPromise","AbstractStoreCursor","store","_store","overrideStore","Error","findByKey","delete","deleteByKey","AbstractQuery","fetchAndSubscribe","_subscribe","subscribe","AbstractStore","connection","keyPath","assert","_connection","findAll","criteria","sort","cursor","toArray","upsertOne","object","upsertOneWithInfo","deleteOne"],"mappings":";;;;;;;;;;;;IAA8BA;;ACA9B;IAI8BC;;;;;;;SAS5BC,aAAA,sBAA8B;;;WACrB,KAAKC,IAAL,GAAYC,IAAZ,CAAiB;aAAM,KAAI,CAACC,MAAL,EAAN;KAAjB,CAAP;;;SAWIC;;;;;6BAAN,iBACEC,QADF;;;;;;;;qBAIsB,KAAKJ,IAAL,EAJtB;;;cAIUK,IAJV;;kBAKSA,IALT;;;;;;;;;qBAOUD,QAAQ,CAACC,IAAD,CAPlB;;;;;;;;;;;;;;;;;;;SAWAC,UAAA,iBAAQF,QAAR,EAA2E;;;WAClE,KAAKD,WAAL,CAAiB;aACtB,MAAI,CAACD,MAAL,GAAcD,IAAd,CAAmB,UAACC,MAAD;eAAYE,QAAQ,CAACF,MAAD,CAApB;OAAnB,CADsB;KAAjB,CAAP;;;SAKDK;;2BAAD;;;;;;mBAEU,KAAKP,IAAL,EAAN;;;;;;;;;;;;;SAIFQ,MAAM,CAACC;;2BAAT;;;;;;;;;wBAE2B,KAAKF,YAAL,EAF3B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;YAEaG,UAFb;;mBAGUA,UAAU,CAACT,IAAX,CAAgB,UAACI,GAAD;qBAASA,GAAG,IAAI,MAAI,CAACH,MAAL,EAAhB;aAAhB,CAAN;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IC7CwBS;;;;;+BAUhBC,KAAZ,EAA0B;gBACxB,0BADwB;;UAEnBC,MAAL,GAAcD,KAAd;;;;;;SAOFE,gBAAA,uBAAcF,KAAd,EAA4B;SACrBC,MAAL,GAAcD,KAAd;;;SAGFV,SAAA,kBAA0B;QACpB,CAAC,KAAKG,GAAV,EAAe,MAAM,IAAIU,KAAJ,CAAU,oCAAV,CAAN;WACP,KAAKH,KAAL,CAAWI,SAAX,CAAqB,KAAKX,GAA1B,CAAR;;;SAGFY,SAAA,mBAAwB;WACf,KAAKL,KAAL,CAAWM,WAAX,CAAuB,KAAKb,GAA5B,CAAP;;;;;wBAdiB;aACV,KAAKQ,MAAZ;;;;;EAXMf;;ICWoBqB;;;;;;;SAG5BC,oBAAA,2BAAkBhB,QAAlB,EAAsD;WAC7C,KAAKiB,UAAL,CAAgBjB,QAAhB,EAA0B,IAA1B,CAAP;;;SAGFkB,YAAA,mBAAUlB,QAAV,EAA8C;WACrC,KAAKiB,UAAL,CAAgBjB,QAAhB,EAA0B,KAA1B,CAAP;;;;;;ICf0BmB;;;yBAUhBC,UAAZ,EAAoCC,OAApC,EAAsD;IACpDC,MAAM,CAACF,UAAD,CAAN;SACKG,WAAL,GAAmBH,UAAnB;SACKC,OAAL,GAAeA,OAAf;;;;;SAYFG,UAAA,iBAAQC,QAAR,EAAoCC,IAApC,EAA0E;WACjE,KAAKC,MAAL,CAAYF,QAAZ,EAAsBC,IAAtB,EAA4B7B,IAA5B,CAAiC,UAAC8B,MAAD;aACtCA,MAAM,CAACC,OAAP,EADsC;KAAjC,CAAP;;;SA0BIC;;;;;6BAAN,iBAAgBC,MAAhB;;;;;;;qBACuB,KAAKC,iBAAL,CAAuBD,MAAvB,CADvB;;;cACQhC,MADR;+CAESA,MAAM,CAACgC,MAFhB;;;;;;;;;;;;;;;SA2BAE,YAAA,mBAAUF,MAAV,EAAwC;WAC/B,KAAKhB,WAAL,CAAiBgB,MAAM,CAAC,KAAKT,OAAN,CAAvB,CAAP;;;;;wBAhE2B;aACpB,KAAKE,WAAZ;;;;;;;;;;;;;"}