{"version":3,"file":"index-node.mjs","sources":["../src/MongoCursor.ts","../src/MongoQueryCollection.ts","../src/MongoQuerySingleItem.ts","../src/MongoStore.ts","../src/MongoConnection.ts","../src/createMongoSubscribeStore.ts"],"sourcesContent":["import { AbstractStoreCursor } from \"liwi-store\";\nimport type { AllowedKeyValue } from \"liwi-store\";\nimport type { FindCursor } from \"mongodb\";\nimport type { MongoBaseModel } from \"./MongoBaseModel\";\nimport type MongoStore from \"./MongoStore\";\n\nexport default class MongoCursor<\n  Model extends MongoBaseModel<KeyValue>,\n  Result extends Partial<Model> = Model,\n  KeyValue extends AllowedKeyValue = Model[\"_id\"],\n> extends AbstractStoreCursor<\n  MongoStore<Model, KeyValue>,\n  KeyValue,\n  Model,\n  Result\n> {\n  // key in AbstractCursor\n\n  private readonly cursor: FindCursor<Result>;\n\n  private _result?: Result | null;\n\n  constructor(store: MongoStore<Model, KeyValue>, cursor: FindCursor<Result>) {\n    super(store);\n    this.cursor = cursor;\n  }\n\n  advance(count: number): void {\n    this.cursor.skip(count);\n  }\n\n  next(): Promise<KeyValue | undefined> {\n    return this.cursor.next().then((value) => {\n      this._result = value;\n      this.key = value?._id;\n      return this.key;\n    });\n  }\n\n  override async forEach(\n    callback: (result: Result) => Promise<void> | void,\n  ): Promise<void> {\n    for await (const result of this.cursor) {\n      await callback(result);\n    }\n  }\n\n  limit(newLimit: number): Promise<this> {\n    this.cursor.limit(newLimit);\n    return Promise.resolve(this);\n  }\n\n  override result(): Promise<Result> {\n    if (!this._result) throw new Error(\"Cannot call result() before next()\");\n    return Promise.resolve(this._result);\n  }\n\n  close(): Promise<void> {\n    if (this.cursor) {\n      this.cursor.close();\n    }\n\n    return Promise.resolve();\n  }\n\n  toArray(): Promise<Result[]> {\n    return this.cursor.toArray();\n  }\n}\n","/* eslint-disable complexity */\nimport type {\n  AllowedKeyValue,\n  Changes,\n  QueryOptions,\n  QueryParams,\n  QueryResult,\n  QuerySubscription,\n  SubscribeCallback,\n  Transformer,\n} from \"liwi-store\";\nimport type { Actions } from \"liwi-subscribe-store\";\nimport { AbstractSubscribableStoreQuery } from \"liwi-subscribe-store\";\nimport mingo from \"mingo\";\nimport type {\n  MongoBaseModel,\n  MongoInsertType,\n  MongoKeyPath,\n} from \"./MongoBaseModel\";\nimport type MongoCursor from \"./MongoCursor\";\nimport type MongoStore from \"./MongoStore\";\n\nconst identityTransformer = <\n  Model extends MongoBaseModel<any>,\n  Transformed = Model,\n>(\n  model: Model,\n): Transformed => model as unknown as Transformed;\n\ntype TestCriteria = (obj: any) => boolean;\n\nexport default class MongoQueryCollection<\n  Model extends MongoBaseModel<KeyValue>,\n  Params extends QueryParams<Params> = never,\n  KeyValue extends AllowedKeyValue = Model[\"_id\"],\n  Item extends Record<MongoKeyPath, KeyValue> = Model,\n> extends AbstractSubscribableStoreQuery<\n  MongoKeyPath,\n  KeyValue,\n  Model,\n  MongoInsertType<Model, KeyValue>,\n  Params,\n  Item[]\n> {\n  private readonly store: MongoStore<Model, KeyValue>;\n\n  private readonly options: QueryOptions<Model>;\n\n  private testCriteria?: TestCriteria;\n\n  private readonly transformer: Transformer<Model, Item>;\n\n  constructor(\n    store: MongoStore<Model, KeyValue>,\n    options: QueryOptions<Model>,\n    transformer: Transformer<Model, Item> = identityTransformer,\n  ) {\n    super();\n    this.store = store;\n    this.options = options;\n    this.transformer = transformer;\n  }\n\n  createTestCriteria(): TestCriteria {\n    if (!this.testCriteria) {\n      if (!this.options.criteria) {\n        return () => true;\n      }\n\n      // criteria not supported by mingo: updates will not work\n      if (\"$text\" in this.options.criteria) {\n        return () => false;\n      }\n\n      const mingoQuery = new mingo.Query(this.options.criteria);\n      this.testCriteria = mingoQuery.test.bind(mingoQuery);\n    }\n    return this.testCriteria;\n  }\n\n  async fetch<T>(onFulfilled: (result: QueryResult<Item[]>) => T): Promise<T> {\n    const [result, count] = await Promise.all([\n      this.createMongoCursor().then((cursor) => cursor.toArray()),\n      this.store.count(this.options.criteria),\n    ]);\n\n    return onFulfilled({\n      result: result.map(this.transformer),\n      meta: { total: count },\n      info: {\n        sort: this.options.sort,\n        limit: this.options.limit,\n        keyPath: this.store.keyPath,\n      },\n    });\n  }\n\n  _subscribe(\n    callback: SubscribeCallback<KeyValue, Item[]>,\n    _includeInitial: boolean,\n  ): QuerySubscription {\n    const store = super.getSubscribeStore();\n    const testCriteria: TestCriteria = this.createTestCriteria();\n\n    const promise: Promise<void> = _includeInitial\n      ? this.fetch(({ result, meta, info }: QueryResult<Item[]>) => {\n          callback(null, [\n            {\n              type: \"initial\",\n              initial: result,\n              queryInfo: info,\n              meta,\n            },\n          ]);\n        })\n      : Promise.resolve();\n\n    const unsubscribe = store.subscribe((action: Actions<Model>) => {\n      const changes: Changes<KeyValue, Item[]> = [];\n      switch (action.type) {\n        case \"inserted\": {\n          const filtered = action.next.filter(testCriteria);\n          if (filtered.length > 0) {\n            changes.push({\n              type: \"inserted\",\n              result: filtered.map(this.transformer),\n            });\n          }\n          break;\n        }\n        case \"deleted\": {\n          const filtered = action.prev.filter(testCriteria);\n          if (filtered.length > 0) {\n            changes.push({\n              type: \"deleted\",\n              keys: filtered.map((object) => object[this.store.keyPath]),\n            });\n          }\n          break;\n        }\n        case \"updated\": {\n          const {\n            deleted,\n            updated,\n            inserted,\n          }: {\n            deleted: KeyValue[];\n            updated: Item[];\n            inserted: Item[];\n          } = { deleted: [], updated: [], inserted: [] };\n\n          action.changes.forEach(([prevObject, nextObject]: [Model, Model]) => {\n            if (testCriteria(prevObject)) {\n              if (!testCriteria(nextObject)) {\n                deleted.push(prevObject[this.store.keyPath]);\n              } else {\n                updated.push(this.transformer(nextObject));\n              }\n            } else if (testCriteria(nextObject)) {\n              inserted.push(this.transformer(nextObject));\n            }\n          });\n\n          if (deleted.length > 0) {\n            changes.push({ type: \"deleted\", keys: deleted });\n          }\n          if (updated.length > 0) {\n            changes.push({ type: \"updated\", result: updated });\n          }\n          if (inserted.length > 0) {\n            changes.push({ type: \"inserted\", result: inserted });\n          }\n\n          break;\n        }\n        default:\n          throw new Error(\"Unsupported type\");\n      }\n\n      if (changes.length === 0) return;\n\n      callback(null, changes);\n    });\n    // let _feed;\n    // const promise = this.queryCallback(this.store.query(), this.store.r)\n    //   .changes({\n    //     includeInitial: _includeInitial,\n    //     includeStates: true,\n    //     includeTypes: true,\n    //     includeOffsets: true,\n    //   })\n    //   .then((feed) => {\n    //     if (args.length === 0) {\n    //       _feed = feed;\n    //       delete this._promise;\n    //     }\n    //\n    //     feed.each(callback);\n    //     return feed;\n    //   });\n    //\n    // if (args.length === 0) this._promise = promise;\n\n    return {\n      stop: unsubscribe,\n      cancel: unsubscribe,\n      then: <T, U>(\n        onFulfilled: () => Promise<T> | T,\n        onRejected?: (error: any) => Promise<U> | U,\n      ): Promise<T | U> => promise.then(onFulfilled, onRejected),\n    };\n  }\n\n  private async createMongoCursor(): Promise<\n    MongoCursor<Model, Model, KeyValue>\n  > {\n    const cursor = await this.store.cursor(\n      this.options.criteria,\n      this.options.sort,\n    );\n\n    if (this.options.skip) {\n      cursor.advance(this.options.skip);\n    }\n\n    if (this.options.limit) {\n      await cursor.limit(this.options.limit);\n    }\n\n    return cursor;\n  }\n}\n","import type {\n  AllowedKeyValue,\n  Changes,\n  QueryOptions,\n  QueryParams,\n  QueryResult,\n  QuerySubscription,\n  SubscribeCallback,\n  Transformer,\n} from \"liwi-store\";\nimport type { Actions } from \"liwi-subscribe-store\";\nimport { AbstractSubscribableStoreQuery } from \"liwi-subscribe-store\";\nimport mingo from \"mingo\";\nimport type {\n  MongoBaseModel,\n  MongoInsertType,\n  MongoKeyPath,\n} from \"./MongoBaseModel\";\nimport type MongoCursor from \"./MongoCursor\";\nimport type MongoStore from \"./MongoStore\";\n\nconst identityTransformer = <\n  Model extends MongoBaseModel<any>,\n  Transformed = Model,\n>(\n  model: Model,\n): Transformed => model as unknown as Transformed;\n\ntype TestCriteria = (obj: any) => boolean;\n\nexport default class MongoQuerySingleItem<\n  Model extends MongoBaseModel<KeyValue>,\n  Params extends QueryParams<Params> = never,\n  Result extends Record<MongoKeyPath, KeyValue> | null = Model | null,\n  KeyValue extends AllowedKeyValue = Model[\"_id\"],\n> extends AbstractSubscribableStoreQuery<\n  MongoKeyPath,\n  KeyValue,\n  Model,\n  MongoInsertType<Model, KeyValue>,\n  Params,\n  Result\n> {\n  private readonly store: MongoStore<Model, KeyValue>;\n\n  private readonly options: QueryOptions<Model>;\n\n  private testCriteria?: TestCriteria;\n\n  private readonly transformer: Transformer<Model, Result>;\n\n  constructor(\n    store: MongoStore<Model, KeyValue>,\n    options: QueryOptions<Model>,\n    transformer: Transformer<Model, Result> = identityTransformer,\n  ) {\n    super();\n    this.store = store;\n    this.options = options;\n    this.transformer = transformer;\n  }\n\n  createMingoTestCriteria(): TestCriteria {\n    if (!this.testCriteria) {\n      if (!this.options.criteria) {\n        return () => true;\n      }\n\n      const mingoQuery = new mingo.Query(this.options.criteria);\n      this.testCriteria = mingoQuery.test.bind(mingoQuery);\n    }\n\n    return this.testCriteria;\n  }\n\n  async fetch<T>(onFulfilled: (result: QueryResult<Result>) => T): Promise<T> {\n    const cursor = await this.createMongoCursor();\n    await cursor.limit(1);\n    return cursor.toArray().then((result: Model[]) => {\n      const item: Result =\n        result.length === 0 ? (null as Result) : this.transformer(result[0]!);\n      return onFulfilled({\n        result: item,\n        meta: { total: result === null ? 0 : 1 },\n        info: {\n          limit: 1,\n          keyPath: this.store.keyPath,\n        },\n      });\n    });\n  }\n\n  _subscribe(\n    callback: SubscribeCallback<KeyValue, Result>,\n    _includeInitial: boolean,\n  ): QuerySubscription {\n    const store = super.getSubscribeStore();\n    const testCriteria: TestCriteria = this.createMingoTestCriteria();\n\n    const promise: Promise<void> = _includeInitial\n      ? this.fetch(({ result, meta, info }: QueryResult<Result>) => {\n          callback(null, [\n            {\n              type: \"initial\",\n              initial: result,\n              queryInfo: info,\n              meta,\n            },\n          ]);\n        })\n      : Promise.resolve();\n\n    const unsubscribe = store.subscribe(async (action: Actions<Model>) => {\n      const changes: Changes<KeyValue, Result> = [];\n      switch (action.type) {\n        case \"inserted\": {\n          const filtered = action.next.filter(testCriteria);\n          if (filtered.length > 0) {\n            changes.push({\n              type: \"updated\",\n              result: this.transformer(filtered[0]!),\n            });\n          }\n          break;\n        }\n        case \"deleted\": {\n          const filtered = action.prev.filter(testCriteria);\n          if (filtered.length > 0) {\n            changes.push({\n              type: \"deleted\",\n              keys: filtered.map((object) => object[this.store.keyPath]),\n            });\n          }\n          break;\n        }\n        case \"updated\": {\n          const filtered = action.changes.filter(([prev, next]) =>\n            testCriteria(prev),\n          );\n          if (filtered.length > 0) {\n            if (this.options.sort) {\n              const { result } = await this.fetch((res) => res);\n              changes.push({\n                type: \"updated\",\n                result,\n              });\n            } else if (filtered.length !== 1) {\n              throw new Error(\n                \"should not match more than 1, use sort if you can have multiple match\",\n              );\n            } else {\n              const [, next] = filtered[0]!;\n              changes.push({\n                type: \"updated\",\n                result: testCriteria(next) ? this.transformer(next) : null!,\n              });\n            }\n          } else if (filtered.length === 0) {\n          }\n          break;\n        }\n        default:\n          throw new Error(\"Unsupported type\");\n      }\n\n      if (changes.length === 0) return;\n\n      callback(null, changes);\n    });\n\n    return {\n      stop: unsubscribe,\n      cancel: unsubscribe,\n      then: <T, U>(\n        onFulfilled: () => Promise<T> | T,\n        onRejected?: (error: any) => Promise<U> | U,\n      ): Promise<T | U> => promise.then(onFulfilled, onRejected),\n    };\n  }\n\n  private async createMongoCursor(): Promise<\n    MongoCursor<Model, Model, KeyValue>\n  > {\n    const cursor = await this.store.cursor(\n      this.options.criteria,\n      this.options.sort,\n    );\n\n    if (this.options.limit) {\n      await cursor.limit(this.options.limit);\n    }\n\n    return cursor;\n  }\n}\n","import type {\n  AllowedKeyValue,\n  Criteria,\n  OptionalBaseModelKeysForInsert,\n  QueryOptions,\n  QueryParams,\n  Sort,\n  SubscribableStore,\n  Transformer,\n  Update,\n  UpsertPartialObject,\n  UpsertResult,\n} from \"liwi-store\";\nimport type {\n  Collection,\n  Filter,\n  FindCursor,\n  MongoClient,\n  UpdateFilter,\n} from \"mongodb\";\nimport mongodb from \"mongodb\";\nimport type {\n  MongoBaseModel,\n  MongoInsertType,\n  MongoKeyPath,\n} from \"./MongoBaseModel.ts\";\nimport type MongoConnection from \"./MongoConnection.ts\";\nimport MongoCursor from \"./MongoCursor.ts\";\nimport MongoQueryCollection from \"./MongoQueryCollection.ts\";\nimport MongoQuerySingleItem from \"./MongoQuerySingleItem.ts\";\n\nexport interface MongoUpsertResult<\n  KeyValue extends AllowedKeyValue,\n  Model extends MongoBaseModel<KeyValue>,\n> extends UpsertResult<Model> {\n  object: Model;\n  inserted: boolean;\n}\n\nexport default class MongoStore<\n  Model extends MongoBaseModel<KeyValue>,\n  KeyValue extends AllowedKeyValue = Model[MongoKeyPath],\n> implements\n    SubscribableStore<\n      MongoKeyPath,\n      KeyValue,\n      Model,\n      MongoInsertType<Model>,\n      MongoConnection\n    >\n{\n  readonly keyPath: MongoKeyPath = \"_id\";\n\n  readonly connection: MongoConnection;\n\n  private _collection: Collection<Model> | Promise<Collection<Model>>;\n\n  constructor(connection: MongoConnection, collectionName: string) {\n    this.connection = connection;\n\n    if (!collectionName) {\n      throw new Error(`Invalid collectionName: \"${collectionName}\"`);\n    }\n\n    this._collection = connection.getConnection().then(\n      (client: MongoClient) => {\n        this._collection = client.db().collection(collectionName);\n        return this._collection;\n      },\n      (error: Error) => {\n        this._collection = Promise.reject(error);\n        return this._collection;\n      },\n    );\n  }\n\n  get collection(): Promise<Collection<Model>> {\n    if (this.connection.connectionFailed) {\n      return Promise.reject(new Error(\"MongoDB connection failed\"));\n    }\n\n    return Promise.resolve(this._collection);\n  }\n\n  createQuerySingleItem<\n    Result extends Record<MongoKeyPath, KeyValue> = Model,\n    Params extends QueryParams<Params> = never,\n  >(\n    options: QueryOptions<Model>,\n    transformer?: Transformer<Model, Result>,\n  ): MongoQuerySingleItem<Model, Params, Result, KeyValue> {\n    return new MongoQuerySingleItem<Model, Params, Result, KeyValue>(\n      this,\n      options,\n      transformer,\n    );\n  }\n\n  createQueryCollection<\n    Item extends Record<MongoKeyPath, KeyValue> = Model,\n    Params extends QueryParams<Params> = never,\n  >(\n    options: QueryOptions<Model>,\n    transformer?: Transformer<Model, Item>,\n  ): MongoQueryCollection<Model, Params, Model[\"_id\"], Item> {\n    return new MongoQueryCollection<Model, Params, KeyValue, Item>(\n      this,\n      options,\n      transformer,\n    );\n  }\n\n  async insertOne(object: MongoInsertType<Model>): Promise<Model> {\n    if (!object._id) {\n      object._id = new mongodb.ObjectId().toString() as Model[\"_id\"];\n    }\n\n    if (!object.created) object.created = new Date();\n    if (!object.updated) object.updated = new Date();\n\n    const collection = await this.collection;\n    const { acknowledged: isAcknowledged } = await collection.insertOne(\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n      object as any,\n    );\n    if (!isAcknowledged) {\n      throw new Error(\"Fail to insert\");\n    }\n\n    return object as Model;\n  }\n\n  async replaceOne(object: Model): Promise<Model> {\n    if (!object.updated) object.updated = new Date();\n\n    const collection = await this.collection;\n    await collection.replaceOne({ _id: object._id } as Filter<Model>, object);\n    return object;\n  }\n\n  async upsertOne<\n    K extends Exclude<\n      keyof Model,\n      MongoKeyPath | OptionalBaseModelKeysForInsert\n    >,\n  >(\n    object: UpsertPartialObject<MongoKeyPath, KeyValue, Model, K>,\n    setOnInsertPartialObject?: Update<Model>[\"$setOnInsert\"],\n  ): Promise<Model> {\n    const result = await this.upsertOneWithInfo(\n      object,\n      setOnInsertPartialObject,\n    );\n    return result.object;\n  }\n\n  async upsertOneWithInfo<\n    K extends Exclude<\n      keyof Model,\n      MongoKeyPath | OptionalBaseModelKeysForInsert\n    >,\n  >(\n    object: UpsertPartialObject<MongoKeyPath, KeyValue, Model, K>,\n    setOnInsertPartialObject?: Update<Model>[\"$setOnInsert\"],\n  ): Promise<MongoUpsertResult<KeyValue, Model>> {\n    const $setOnInsert: Update<Model>[\"$setOnInsert\"] = {\n      // @ts-expect-error -- created is Date as set in BaseModel\n      created: object.created || new Date(),\n      ...setOnInsertPartialObject,\n    };\n\n    if (!object.updated) {\n      (object as MongoBaseModel).updated = new Date();\n    }\n\n    const $set: Partial<typeof object> = { ...object };\n    delete $set.created;\n\n    const collection = await this.collection;\n\n    const { upsertedCount } = await collection.updateOne(\n      { _id: object._id } as Filter<Model>,\n      { $set, $setOnInsert } as UpdateFilter<Model>,\n      { upsert: true },\n    );\n\n    if (upsertedCount) {\n      Object.assign(object, $setOnInsert);\n    }\n\n    return { object: object as unknown as Model, inserted: !!upsertedCount };\n  }\n\n  replaceSeveral(objects: Model[]): Promise<Model[]> {\n    return Promise.all(objects.map((object: Model) => this.replaceOne(object)));\n  }\n\n  async partialUpdateByKey(\n    key: KeyValue,\n    partialUpdate: Update<Model>,\n    criteria?: Criteria<Model>,\n  ): Promise<Model> {\n    const collection = await this.collection;\n    const commandResult = await collection.updateOne(\n      { _id: key, ...criteria } as Filter<Model>,\n      partialUpdate as UpdateFilter<Model>,\n    );\n    if (!commandResult.acknowledged) {\n      console.error(commandResult);\n      throw new Error(\"Update failed\");\n    }\n    const object = await this.findByKey(key);\n    return object!;\n  }\n\n  partialUpdateOne(\n    object: Model,\n    partialUpdate: Update<Model>,\n  ): Promise<Model> {\n    return this.partialUpdateByKey(object._id, partialUpdate);\n  }\n\n  partialUpdateMany(\n    criteria: Criteria<Model>,\n    partialUpdate: Update<Model>,\n  ): Promise<void> {\n    return this.collection\n      .then((collection) =>\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n        collection.updateMany(criteria as Filter<Model>, partialUpdate as any),\n      )\n      .then((res) => undefined); // TODO return updated object\n  }\n\n  deleteByKey(key: KeyValue, criteria?: Criteria<Model>): Promise<void> {\n    return this.collection\n      .then((collection) =>\n        collection.deleteOne({ _id: key, ...criteria } as Filter<Model>),\n      )\n      .then(() => undefined);\n  }\n\n  deleteOne(object: Model): Promise<void> {\n    return this.deleteByKey(object._id);\n  }\n\n  deleteMany(selector: Criteria<Model>): Promise<void> {\n    return this.collection\n      .then((collection) => collection.deleteMany(selector as Filter<Model>))\n      .then(() => undefined);\n  }\n\n  async count(filter?: Criteria<Model>): Promise<number> {\n    const collection = await this.collection;\n    return filter\n      ? collection.countDocuments(filter as Filter<Model>)\n      : collection.countDocuments();\n  }\n\n  async cursor<Result extends Partial<Model> = Model>(\n    filter?: Criteria<Model>,\n    sort?: Sort<Model>,\n  ): Promise<MongoCursor<Model, Result, KeyValue>> {\n    const collection = await this.collection;\n    const findCursor = filter\n      ? collection.find<Result>(filter as Filter<Model>)\n      : (collection.find() as unknown as FindCursor<Result>);\n    if (sort) findCursor.sort(sort);\n    return new MongoCursor<Model, Result, KeyValue>(this, findCursor);\n  }\n\n  async findByKey(\n    key: KeyValue,\n    criteria?: Criteria<Model>,\n  ): Promise<Model | undefined> {\n    const collection = await this.collection;\n    const result = await collection.findOne<Model>({\n      _id: key,\n      ...criteria,\n    } as Filter<Model>);\n    return result || undefined;\n  }\n\n  findAll(criteria?: Criteria<Model>, sort?: Sort<Model>): Promise<Model[]> {\n    return this.cursor<Model>(criteria, sort).then((cursor) =>\n      cursor.toArray(),\n    );\n  }\n\n  async findOne(\n    filter: Criteria<Model>,\n    sort?: Sort<Model>,\n  ): Promise<Model | undefined> {\n    const collection = await this.collection;\n    const result = await collection.findOne<Model>(filter as Filter<Model>, {\n      sort,\n    });\n    return result || undefined;\n  }\n}\n","import { AbstractConnection } from \"liwi-store\";\nimport mongodb from \"mongodb\";\nimport { Logger } from \"nightingale-logger\";\n\nconst logger = new Logger(\"liwi:mongo:MongoConnection\");\n\nexport interface MongoConfig {\n  host?: string;\n  port?: number | string;\n  database: string;\n  user?: string;\n  password?: string;\n}\n\nexport default class MongoConnection extends AbstractConnection {\n  _connection?: mongodb.MongoClient;\n\n  _connecting?: Promise<mongodb.MongoClient>;\n\n  connectionFailed?: boolean;\n\n  // TODO interface\n  constructor({\n    host = \"localhost\",\n    port = \"27017\",\n    database,\n    user,\n    password,\n  }: MongoConfig) {\n    super();\n\n    if (!database) {\n      throw new Error(\"Missing config database\");\n    }\n\n    const buildConnectionString = (redactCredentials: boolean): string =>\n      `mongodb://${\n        user\n          ? `${\n              redactCredentials\n                ? `${user.slice(0, 2)}[redacted]`\n                : encodeURIComponent(user)\n            }:${\n              redactCredentials\n                ? \"[redacted]\"\n                : encodeURIComponent(password ?? \"\")\n            }@`\n          : \"\"\n      }${host}:${port}/${encodeURIComponent(database)}`;\n\n    const connectionString = buildConnectionString(false);\n    const connectionStringRedacted = buildConnectionString(true);\n\n    this.connect(connectionString, connectionStringRedacted);\n  }\n\n  connect(connectionString: string, connectionStringRedacted: string): void {\n    logger.info(\"connecting\", { connectionStringRedacted });\n\n    const connectPromise = mongodb.MongoClient.connect(connectionString)\n      .then((connection) => {\n        logger.info(\"connected\", { connectionStringRedacted });\n        connection.on(\"close\", () => {\n          logger.warn(\"close\", { connectionStringRedacted });\n          this.connectionFailed = true;\n          this.getConnection = () => {\n            throw new Error(\"MongoDB connection closed\");\n          };\n        });\n        connection.on(\"timeout\", () => {\n          logger.warn(\"timeout\", { connectionStringRedacted });\n          this.connectionFailed = true;\n          this.getConnection = () => {\n            throw new Error(\"MongoDB connection timeout\");\n          };\n        });\n        connection.on(\"reconnect\", () => {\n          logger.warn(\"reconnect\", { connectionStringRedacted });\n          this.connectionFailed = false;\n          this.getConnection = () => Promise.resolve(this._connection!);\n        });\n        connection.on(\"error\", (err) => {\n          logger.warn(\"error\", { connectionStringRedacted, err });\n        });\n\n        this._connection = connection;\n        this._connecting = undefined;\n        this.getConnection = () => Promise.resolve(this._connection!);\n        return connection;\n      })\n      .catch((error: unknown) => {\n        logger.info(\"not connected\", { connectionStringRedacted });\n        console.error((error as Error).message || error);\n        // throw err;\n        process.nextTick(() => {\n          // eslint-disable-next-line unicorn/no-process-exit\n          process.exit(1);\n        });\n\n        throw error;\n      });\n\n    this.getConnection = () => Promise.resolve(connectPromise);\n    this._connecting = this.getConnection();\n  }\n\n  getConnection(): Promise<mongodb.MongoClient> {\n    throw new Error(\"call connect()\");\n  }\n\n  async close(): Promise<void> {\n    this.getConnection = () => Promise.reject(new Error(\"Connection closed\"));\n    if (this._connection) {\n      await this._connection.close();\n      this._connection = undefined;\n    } else if (this._connecting) {\n      await this._connecting;\n      await this.close();\n    }\n  }\n}\n","import type { AllowedKeyValue } from \"liwi-store\";\nimport { SubscribeStore } from \"liwi-subscribe-store\";\nimport type {\n  MongoBaseModel,\n  MongoInsertType,\n  MongoKeyPath,\n} from \"./MongoBaseModel\";\nimport type MongoConnection from \"./MongoConnection\";\nimport type MongoStore from \"./MongoStore\";\n\nexport default function createMongoSubscribeStore<\n  Model extends MongoBaseModel<KeyValue>,\n  KeyValue extends AllowedKeyValue = Model[MongoKeyPath],\n>(\n  mongoStore: MongoStore<Model, KeyValue>,\n): SubscribeStore<\n  MongoKeyPath,\n  KeyValue,\n  Model,\n  MongoInsertType<Model, KeyValue>,\n  MongoConnection,\n  MongoStore<Model, KeyValue>\n> {\n  return new SubscribeStore(mongoStore);\n}\n\nexport { type SubscribeStore } from \"liwi-subscribe-store\";\n"],"names":["identityTransformer"],"mappings":"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"}