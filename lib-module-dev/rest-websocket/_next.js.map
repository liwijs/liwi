{"version":3,"sources":["../../src/rest-websocket/_next.js"],"names":["Logger","MAX_OPENED_CURSORS","logger","init","io","restService","on","openCursors","Map","timeouts","activeListeners","closeCursor","clearTimeout","id","delete","close","socket","forEach","cursor","timeout","listener","nextIdCursor","args","callback","type","restName","info","size","options","createCursor","set","setTimeout","warn","then","toArray","results","catch","err","message","typeCursorAction","idCursor","cursorArgs","get","result"],"mappings":"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","file":"_next.js","sourcesContent":["import Logger from 'nightingale-logger';\n\nconst MAX_OPENED_CURSORS = 5;\nconst logger = new Logger('liwi:rest-websocket');\n\nexport default function init(io, restService) {\n  io.on('connection', socket => {\n    let openCursors = new Map();\n    let timeouts = new Map();\n    let activeListeners = new Map();\n\n    const closeCursor = id => {\n      clearTimeout(timeouts[id]);\n      timeouts.delete(id);\n      openCursors[id].close();\n      openCursors.delete(id);\n    };\n\n    socket.on('disconnect', () => {\n      openCursors.forEach(cursor => cursor.close());\n      timeouts.forEach(timeout => clearTimeout(timeout));\n      activeListeners.forEach(listener => listener.close());\n\n      openCursors = null;\n      timeouts = null;\n      activeListeners = null;\n    });\n\n    let nextIdCursor = 1;\n\n    socket.on(\n      'rest',\n      (\n        { type, restName }: { type: string, restName: string },\n        args: Array<any>,\n        callback: Function,\n      ) => {\n        logger.info('rest', { type, restName, args });\n        switch (type) {\n          case 'createCursor': {\n            if (openCursors.size > MAX_OPENED_CURSORS) return callback('too many cursors');\n\n            const id = nextIdCursor++;\n            const [options] = args;\n            const cursor = restService.createCursor(restName, options);\n            if (!cursor) return callback('failed to create cursor');\n\n            timeouts.set(\n              id,\n              setTimeout(() => {\n                logger.warn('socket closed by timeout', { id, restName });\n                closeCursor(id);\n              }),\n            );\n\n            return callback(null, id);\n          }\n\n          case 'cursor toArray': {\n            const [options] = args;\n            return restService\n              .createCursor(restName, options)\n              .then(cursor => cursor.toArray())\n              .then(results => callback(null, results))\n              .catch(err => callback(err.message));\n          }\n\n          case 'cursor': {\n            const [{ type: typeCursorAction, id: idCursor }, cursorArgs] = args;\n\n            const cursor = openCursors.get(idCursor);\n            if (!cursor) return callback(`failed to find cursor \"${idCursor}\"`);\n            switch (typeCursorAction) {\n              case 'close':\n                closeCursor(idCursor);\n                return callback();\n\n              case 'advance':\n              case 'next':\n              case 'count':\n                // eslint-disable-next-line prettier/prettier\n                return cursor[type](...cursorArgs)\n                  .then(result => callback(null, result))\n                  .catch(err => callback(err.message || err));\n              /* cursor.next().then((key) => {\n                                if (!key) return callback(null);\n                                return cursor.result();\n                            }).then(result => {\n                                    response(null, restService.transform(data));\n                                });\n                            }, () => {\n                                response(null);\n                            }); */\n\n              default:\n                callback(`Unknown command: \"${type}\"`);\n            }\n\n            break;\n          }\n\n          case 'insertOne':\n          case 'updateOne':\n          case 'updateSeveral':\n          case 'partialUpdateByKey':\n          case 'partialUpdateOne':\n          case 'partialUpdateMany':\n          case 'deleteByKey':\n          case 'deleteOne':\n          case 'findOne':\n            // eslint-disable-next-line prettier/prettier\n            return restService[type](restName, ...args)\n              .then(result => callback(null, result))\n              .catch(err => callback(err.message || err));\n\n          default:\n            callback(`Unknown command: \"${type}\"`);\n        }\n      },\n    );\n  });\n}\n"]}